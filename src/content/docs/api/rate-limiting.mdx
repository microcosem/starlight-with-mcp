---
title: Rate limiting
description: Understanding API rate limits and how to handle them
---

# Rate limiting

This guide explains how rate limiting works in the Pet Store API and how to handle rate limit responses effectively.

## Overview

Rate limiting helps ensure fair usage of the API and protects our infrastructure. Different rate limits apply based on your authentication status and API plan.

## Rate limit tiers

### Unauthenticated requests

- **100 requests per hour**
- **10 requests per minute**
- Limited to read-only operations

### Authenticated requests

- **1,000 requests per hour**
- **100 requests per minute**
- Full access to all operations

### Premium plans

- **10,000 requests per hour**
- **1,000 requests per minute**
- Priority support and advanced features

## Rate limit headers

All API responses include rate limit information in headers:

```
X-RateLimit-Limit: 1000
X-RateLimit-Remaining: 999
X-RateLimit-Reset: 1640995200
```

### Header fields

| Header | Description | Example |
|--------|-------------|---------|
| `X-RateLimit-Limit` | Maximum requests allowed in the time window | `1000` |
| `X-RateLimit-Remaining` | Number of requests remaining in current window | `999` |
| `X-RateLimit-Reset` | Unix timestamp when the rate limit resets | `1640995200` |

## Rate limit response

When you exceed the rate limit, you'll receive a `429 Too Many Requests` response:

```json
{
  "code": 429,
  "message": "Rate limit exceeded. Try again in 60 seconds."
}
```

## Handling rate limits

### 1. Check rate limit headers

Always check the rate limit headers to monitor your usage:

```javascript
const response = await fetch('https://api.petstore.com/v1/pets');
const remaining = response.headers.get('X-RateLimit-Remaining');
const reset = response.headers.get('X-RateLimit-Reset');

console.log(`Remaining requests: ${remaining}`);
console.log(`Rate limit resets at: ${new Date(reset * 1000)}`);
```

### 2. Implement exponential backoff

When you hit a rate limit, implement exponential backoff:

```javascript
async function makeRequestWithRetry(url, options = {}, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url, options);
      
      if (response.status === 429) {
        const resetTime = response.headers.get('X-RateLimit-Reset');
        const waitTime = Math.max((resetTime * 1000) - Date.now(), 1000 * (i + 1));
        
        console.log(`Rate limited. Waiting ${waitTime}ms before retry...`);
        await new Promise(resolve => setTimeout(resolve, waitTime));
        continue;
      }
      
      return response;
    } catch (error) {
      if (i === maxRetries - 1) throw error;
    }
  }
}
```

### 3. Python example

```python
import requests
import time
from datetime import datetime

def make_request_with_retry(url, headers=None, max_retries=3):
    for i in range(max_retries):
        try:
            response = requests.get(url, headers=headers)
            
            if response.status_code == 429:
                reset_time = int(response.headers.get('X-RateLimit-Reset', 0))
                wait_time = max(reset_time - int(time.time()), (i + 1) * 60)
                
                print(f"Rate limited. Waiting {wait_time}s before retry...")
                time.sleep(wait_time)
                continue
            
            return response
            
        except requests.exceptions.RequestException as e:
            if i == max_retries - 1:
                raise e
            time.sleep(2 ** i)  # Exponential backoff
```

## Best practices

### 1. Monitor your usage

Track your rate limit usage to avoid hitting limits:

```javascript
class RateLimitMonitor {
  constructor() {
    this.remaining = Infinity;
    this.resetTime = 0;
  }
  
  updateFromHeaders(headers) {
    this.remaining = parseInt(headers.get('X-RateLimit-Remaining') || '0');
    this.resetTime = parseInt(headers.get('X-RateLimit-Reset') || '0');
  }
  
  shouldThrottle() {
    return this.remaining < 10;
  }
  
  getTimeUntilReset() {
    return Math.max(0, this.resetTime * 1000 - Date.now());
  }
}
```

### 2. Implement request queuing

For high-volume applications, implement request queuing:

```javascript
class RequestQueue {
  constructor(maxConcurrent = 5) {
    this.queue = [];
    this.running = 0;
    this.maxConcurrent = maxConcurrent;
  }
  
  async add(requestFn) {
    return new Promise((resolve, reject) => {
      this.queue.push({ requestFn, resolve, reject });
      this.process();
    });
  }
  
  async process() {
    if (this.running >= this.maxConcurrent || this.queue.length === 0) {
      return;
    }
    
    this.running++;
    const { requestFn, resolve, reject } = this.queue.shift();
    
    try {
      const result = await requestFn();
      resolve(result);
    } catch (error) {
      reject(error);
    } finally {
      this.running--;
      this.process();
    }
  }
}
```

### 3. Cache responses

Reduce API calls by caching responses:

```javascript
const cache = new Map();

async function cachedRequest(url, ttl = 300000) { // 5 minutes
  const cached = cache.get(url);
  if (cached && Date.now() - cached.timestamp < ttl) {
    return cached.data;
  }
  
  const response = await fetch(url);
  const data = await response.json();
  
  cache.set(url, {
    data,
    timestamp: Date.now()
  });
  
  return data;
}
```

## Rate limit by endpoint

Different endpoints may have different rate limits:

| Endpoint | Rate Limit | Notes |
|----------|------------|-------|
| `GET /pets` | Standard | Read operations |
| `POST /pets` | Reduced | Write operations |
| `DELETE /pets/{id}` | Reduced | Destructive operations |
| `GET /orders` | Standard | Read operations |

## Upgrading your plan

If you consistently hit rate limits, consider upgrading:

1. **Contact support** - Email support@petstore.com
2. **Provide usage data** - Share your current usage patterns
3. **Discuss requirements** - Explain your use case and requirements
4. **Review options** - Choose the best plan for your needs

## Monitoring and alerts

Set up monitoring to track your rate limit usage:

```javascript
// Monitor rate limit usage
function logRateLimitUsage(headers) {
  const remaining = headers.get('X-RateLimit-Remaining');
  const limit = headers.get('X-RateLimit-Limit');
  const usage = ((limit - remaining) / limit) * 100;
  
  if (usage > 80) {
    console.warn(`High rate limit usage: ${usage.toFixed(1)}%`);
  }
}
```

## Next steps

- **[Error handling](/api/errors/)** - Handle rate limit errors gracefully
- **[Authentication](/guides/authentication/)** - Get higher rate limits with authentication
- **[API reference](/api/petstore-api/)** - Explore all endpoints and their limits

---

> **ðŸ’¡ Tip:** Always implement proper error handling for rate limits in production applications to ensure your service remains reliable. 