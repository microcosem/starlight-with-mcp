---
title: Best practices
description: Recommended patterns and tips for using the Pet Store API effectively
---

# Best practices

This guide provides recommended patterns and tips for using the Pet Store API effectively in production applications.

## API design principles

### 1. RESTful conventions

Follow RESTful principles for consistent API usage:

- **Use appropriate HTTP methods**: GET for reading, POST for creating, PUT for updating, DELETE for removing
- **Use plural nouns for resources**: `/pets` not `/pet`
- **Use hierarchical URLs**: `/pets/{id}/orders` for nested resources
- **Return appropriate status codes**: 200 for success, 201 for created, 204 for deleted

### 2. Resource naming

Use clear, consistent naming conventions:

```javascript
// Good
GET /pets
POST /pets
GET /pets/{id}
PUT /pets/{id}
DELETE /pets/{id}

// Avoid
GET /getPets
POST /createPet
GET /pet/{id}
```

## Error handling

### 1. Always check response status

```javascript
async function makeApiRequest(url, options = {}) {
  const response = await fetch(url, options);
  
  if (!response.ok) {
    const error = await response.json();
    throw new Error(`${error.code}: ${error.message}`);
  }
  
  return response.json();
}
```

### 2. Implement retry logic

```javascript
async function retryRequest(requestFn, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await requestFn();
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      
      // Wait before retrying (exponential backoff)
      await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, i)));
    }
  }
}
```

### 3. Handle specific error types

```javascript
async function handleApiError(error) {
  if (error.message.includes('401')) {
    // Handle authentication errors
    await refreshToken();
  } else if (error.message.includes('429')) {
    // Handle rate limiting
    await waitForRateLimit();
  } else if (error.message.includes('500')) {
    // Handle server errors
    logError(error);
    throw new Error('Service temporarily unavailable');
  }
}
```

## Performance optimization

### 1. Use pagination

Always use pagination for list endpoints:

```javascript
async function getAllPets() {
  const allPets = [];
  let page = 1;
  const limit = 100;
  
  while (true) {
    const response = await fetch(`/pets?limit=${limit}&offset=${(page - 1) * limit}`);
    const pets = await response.json();
    
    if (pets.length === 0) break;
    
    allPets.push(...pets);
    page++;
  }
  
  return allPets;
}
```

### 2. Implement caching

Cache responses to reduce API calls:

```javascript
class ApiCache {
  constructor(ttl = 300000) { // 5 minutes
    this.cache = new Map();
    this.ttl = ttl;
  }
  
  get(key) {
    const item = this.cache.get(key);
    if (item && Date.now() - item.timestamp < this.ttl) {
      return item.data;
    }
    return null;
  }
  
  set(key, data) {
    this.cache.set(key, {
      data,
      timestamp: Date.now()
    });
  }
}
```

### 3. Batch requests

When possible, batch multiple operations:

```javascript
// Instead of multiple requests
const pet1 = await createPet(petData1);
const pet2 = await createPet(petData2);
const pet3 = await createPet(petData3);

// Use batch endpoint if available
const pets = await createPets([petData1, petData2, petData3]);
```

## Security best practices

### 1. Secure API key storage

```javascript
// Never hardcode API keys
const apiKey = process.env.PETSTORE_API_KEY;

// Use environment variables
const headers = {
  'Authorization': `Bearer ${apiKey}`,
  'Content-Type': 'application/json'
};
```

### 2. Validate input data

```javascript
function validatePetData(data) {
  const errors = [];
  
  if (!data.name || data.name.length < 1) {
    errors.push('Name is required');
  }
  
  if (!data.photoUrls || !Array.isArray(data.photoUrls)) {
    errors.push('Photo URLs must be an array');
  }
  
  if (data.status && !['available', 'pending', 'sold'].includes(data.status)) {
    errors.push('Invalid status value');
  }
  
  return errors;
}
```

### 3. Use HTTPS

Always use HTTPS in production:

```javascript
const baseUrl = process.env.NODE_ENV === 'production' 
  ? 'https://api.petstore.com/v1'
  : 'http://localhost:3000/v1';
```

## Data management

### 1. Handle large datasets

For large datasets, use streaming or chunking:

```javascript
async function processLargeDataset(url, processor) {
  const response = await fetch(url);
  const reader = response.body.getReader();
  
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    
    // Process chunk of data
    await processor(value);
  }
}
```

### 2. Implement data validation

```javascript
const petSchema = {
  name: { type: 'string', required: true, minLength: 1, maxLength: 50 },
  category: { type: 'object', required: false },
  photoUrls: { type: 'array', required: true, minItems: 1 },
  tags: { type: 'array', required: false },
  status: { type: 'string', enum: ['available', 'pending', 'sold'] }
};

function validateAgainstSchema(data, schema) {
  // Implementation of schema validation
  // Use libraries like Joi, Yup, or Zod
}
```

## Monitoring and logging

### 1. Log API requests

```javascript
async function loggedApiRequest(url, options = {}) {
  const startTime = Date.now();
  
  try {
    const response = await fetch(url, options);
    const duration = Date.now() - startTime;
    
    console.log(`API Request: ${options.method || 'GET'} ${url} - ${response.status} (${duration}ms)`);
    
    return response;
  } catch (error) {
    const duration = Date.now() - startTime;
    console.error(`API Error: ${options.method || 'GET'} ${url} - ${error.message} (${duration}ms)`);
    throw error;
  }
}
```

### 2. Monitor rate limits

```javascript
function monitorRateLimits(headers) {
  const remaining = parseInt(headers.get('X-RateLimit-Remaining') || '0');
  const limit = parseInt(headers.get('X-RateLimit-Limit') || '0');
  const usage = ((limit - remaining) / limit) * 100;
  
  if (usage > 80) {
    console.warn(`High rate limit usage: ${usage.toFixed(1)}%`);
  }
  
  return { remaining, limit, usage };
}
```

## Testing

### 1. Mock API responses

```javascript
// Mock API for testing
const mockApi = {
  pets: [
    { id: 1, name: 'Buddy', status: 'available' },
    { id: 2, name: 'Fluffy', status: 'sold' }
  ],
  
  async get(url) {
    if (url.includes('/pets')) {
      return { json: () => Promise.resolve(this.pets) };
    }
    throw new Error('Not found');
  }
};
```

### 2. Test error scenarios

```javascript
describe('API Error Handling', () => {
  it('should handle 404 errors', async () => {
    // Test implementation
  });
  
  it('should handle rate limiting', async () => {
    // Test implementation
  });
  
  it('should handle network errors', async () => {
    // Test implementation
  });
});
```

## Code examples

### Complete API client

```javascript
class PetStoreApiClient {
  constructor(apiKey, baseUrl = 'https://api.petstore.com/v1') {
    this.apiKey = apiKey;
    this.baseUrl = baseUrl;
    this.cache = new ApiCache();
  }
  
  async request(endpoint, options = {}) {
    const url = `${this.baseUrl}${endpoint}`;
    const headers = {
      'Authorization': `Bearer ${this.apiKey}`,
      'Content-Type': 'application/json',
      ...options.headers
    };
    
    const response = await fetch(url, { ...options, headers });
    
    if (!response.ok) {
      const error = await response.json();
      throw new Error(`${error.code}: ${error.message}`);
    }
    
    return response.json();
  }
  
  async getPets(limit = 20, offset = 0) {
    return this.request(`/pets?limit=${limit}&offset=${offset}`);
  }
  
  async createPet(petData) {
    return this.request('/pets', {
      method: 'POST',
      body: JSON.stringify(petData)
    });
  }
  
  async updatePet(id, petData) {
    return this.request(`/pets/${id}`, {
      method: 'PUT',
      body: JSON.stringify(petData)
    });
  }
  
  async deletePet(id) {
    return this.request(`/pets/${id}`, {
      method: 'DELETE'
    });
  }
}
```

## Next steps

- **[Quick start guide](/guides/quick-start/)** - Get started with the API
- **[Error handling](/api/errors/)** - Learn about error handling
- **[Rate limiting](/api/rate-limiting/)** - Understand rate limits
- **[API reference](/api/petstore-api/)** - Explore all endpoints

---

> **ðŸ’¡ Remember:** These best practices will help you build robust, scalable applications that work reliably with the Pet Store API. 